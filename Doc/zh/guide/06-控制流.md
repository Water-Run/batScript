# 控制流

本节将讲解在`batScript`中程序的控制流.

## 程序的执行顺序

在`batScript`的程序中,程序默认是以顺序的形式从上至下运行的.库载入语句`pkg`和`lib`必须位于最开头的部分.

除非变量在函数/过程中声明,否则变量默认为全局变量.在`batScript`中,变量不会提升.

函数/过程必须先声明,再使用.

对外暴露的`expose`语句必须位于有效代码的最后部分.

## 选择

`batScript`的选择语句是`if-elif-else`:

```batscript
if(1 > 2)
{

}
elif(1 == 2)
{

}
else
{

}
```

其中, `if`是必须的; `elif`和`else`可选.

选择的条件使用`()`包裹,其内的表达式必须是一个布尔值,比如,下列代码:

```batscript
set var_1: num;
if (var_1 = 1) # Nil
{

}
```

就会导致错误.

代码块内多行代码,使用`{}`进行包裹,就如以上代码所示.如果要执行的条件只包含一行代码,那可以使用`:`并跟随对应条件执行的语句:

```batscript
set bigger: bol;
if(1 > 2): bigger = False;
else: bigger = True;
```

### `match-codition-else`  

`match-codition-else`是一`if-else`的语法糖,用于简化对于相同表达式的值判断语句,提升可读性.  
例如,以下`if-else-elif`:  

```batscript
lib Std;

if (myVar == 1): echo('A');
elif (myVar==2): echo('B');
elif (myVar <0)
{
    echo(num | myVar);
    endprogram;
}
else: err Value => "Invalid Value";
```

等效于:  

```batscript
lib Std;

match (myVar)
{
    conditon (1): echo('A');
    condition (2): echo('B');
    condition (3)
    {
        echo(num | myVar);
    }
    else: err Value => "Invalid Value";
}
```

## 循环

`batScript`循环分为两种: 普通循环和可迭代体循环.

### 普通循环

`while`关键字声明一个普通循环.和条件语句一样,循环条件放置在紧随的`()`中,为一个布尔表达式.

循环在不满足条件或`break`时中止.

```batscript
lib Std;

set num_1 = 1;
while(num_1 < 10)
{
    echoline("loop!");
    num_1 = num_1 + 1;
}
```

和条件语句一样,`while`循环也支持单行表示:

```batscript
set num_1 = 0;
while(num_1 ~= 4): num_1 = num_1 + 1;
```

在循环条件的结尾,可以使用`\`后尾随一个变量名.这个变量被称为计数变量,`num`类型,初始值为`0`,每次循环加`1`.

*示例*:

```batscript
lib Std;

while(True) \ i
{
    echo(i);
}
```

等效于:

```batscript
lib Std;

set i: num = 0;
while(True)
{
    echo(i);
    i = i + 1;
}
```

> 注意该计数变量是全局的.如果之前已声明过该名称的变量非`num`类型或为常量,将导致异常,否则,将覆写重名变量的值  

#### `loop`  

`loop`是最简单的`while`循环变体,相当于`while (True)`:  

```batscript
lib Std;

loop
{
    echo(`Forever...`);
}
```

#### `repeat`  

`repeat`简化给定次数的循环.`repeat(num)`相当于`while (i <= num) \ i`:  

```batscript
func smartCal() -> num
{
    sum = 0;
    repeat(100) \ i
    {
        sum = sum + i;
    }
    return sum;
}
```

### 可迭代体循环

可迭代体循环遍历一个可迭代体中的每一项.

其语法为,`iterate([可迭代体] => [声明的可迭代单元的名称])`.例如,遍历一个字符串时,就是从第一个字符开始,到最后一个字符.

可迭代体循环也支持单行的表示和计数变量:

```batscript
lib Std;

set hello_world = "Hello World";
iterate(hello_world => char)
{
    echo(char); # Hello World
}

set nums = n[1, 2, 3];
iterate(nums => one_num) \ counter: echo(one_num); # 123
```

> 注意该可迭代单元的名称和计数变量都是全局的.如果之前已声明过该名称的变量非对应类型变量或为常量,将导致异常,否则,将覆写重名变量的值.

#### `circle`  

`circle`循环是可迭代体循环的变种: 在遍历完最后一项后,又从可迭代体的第一项开始遍历.  

```batscript
lib Std;

let STRINGS = s['A', 'B', 'C'];

circle(STRINGS => str_now)
{
    echo(str_now) # ABCABCABC...
}
```

### `continue`和`break`

`batScript`的循环也支持`continue`和`break`语句来进行控制流控制:

```batscript
lib Std;
lib Math;

set arr_bol = [True, True, False];
while(True) \ count_i
{
    echoline("while loop:");
    if(count_i > 10): break;
    iterate(arr_bol => bol_unit) \ count_j
    {
        echoline("iterate loop:");
        if(not bol_unit): break;
        else: echo(count_j);
    }
    if(isOdd(count_i)): continue;
}
```

## 异常与程序控制

### `err`: 最基础的异常处理

`err`关键字声明一个异常处理.语法为,`err [异常类型] => [异常说明字符串]`.

```batscript
err Unclassified => "一个未分类的异常";
err Index => "一个下标异常";
```

程序会中止并格式化的输出对应错误信息,以`batScript Error | [异常类型] | [异常说明字符串]`的形式:

```powershell
batScript Error | Index | Index out of range
```

默认情况下,程序以`pause`中止形式结束.除非以`err?!`形式声明异常:

```batscript
err?! Math => "数学错误"; # 异常结束后不会暂停程序
```

异常类型部分是可以省略的.此时,默认异常类型为`Unclassified`:

```batscript
err?! "精简的异常形式";
```

常用的异常类型可见下表:

| 名称 | 说明 |
|--|--|
| `Unclassified` | 未分类错误 |
| `Runtime` | 运行时错误 |
| `Index` | 索引错误 |
| `Math` | 数学错误 |
| `Type` | 类型错误 |
| `Value` | 值错误 |
| `Nil` | 空错误 |

异常的类型是可自定义的,以大驼峰的形式.例如,可以声明异常:

```batscript
err?! MyCustom => "我的自定义异常";
```

> 详细的异常类型说明,见[异常类型说明文档]()

### `endprogram`: 结束运行

`endprogram`用于结束程序的运行.和`err`一样,默认为带`pause`的结束,除非在结尾添加`?!`.

```batscript
endprogram; # 正常中止
endprogram?!; # 无pause中止
```

`endprogram`也支持添加`=>`后尾随一个字符串,表示结束后输出的内容.

```batscript
endprogram => "程序由`endprogram`结束";
```

### 分割线  

`batScript`允许为代码添加分割线,使用`---`:  

```batscript
# Part 1...
---
# Part 2...
```

分割线什么也不会做.  

---
**导航**

[上一个](./05-运算符.md) | [下一个](./07-函数和过程.md)  
[教程目录](./01-教程目录.md) | [手册导览](../manual/手册导引.md) | [返回 README](../../../README-zh.md)
