# 类型系统

## 概览

在原生的`.bat`中,变量只能是字符串类型(或是通过指令处理整数).这显然在使用中是非常不便利的.  
`batScript`提供了一个类型系统,包括数字`num`(整数位无限长,小数位保留32位),字符串`str`,布尔值`bool`和一维数组`arr`(指定类型).  
其中,字符串和一维数组被称为可迭代类型,长度均是可变的.  

## 变量基础  

### 变量命名  

在`batScript`中,变量可以由大小写字母,下划线和数字组成.`batScript`区分大小写.  
变量名中必须包含至少一个字母.数字不能位于开头.  
`batScript`规范建议变量采用小写+下划线,常量采用大写+下划线的命名风格.  

### 声明变量

在`batScript`中,通过`set`声明变量.在变量名之后,需要通过`: [类型]`声明变量的类型.  
变量采用小写+下划线的命名规范:  

```batscript
set var_1: num; # 声明num类型变量 var1
```

在声明时,可以通过`=`为变量赋值:  

> 如果变量有赋值,那`batScript`将会自动推导变量的类型,此时变量类型声明可以省略(在本章之后的教学中保留很多不进行省略,通过的显式的表示以巩固对变量类型的认识)  

```batscript
set var_1: bool = true; # 声明bool类型变量 var1, 并赋初始值true
set var_2 = "MyVar"; # 声明str类型变量 var2, 并赋初始值"MyVar". 类型自动推导为`str`  
set var_3 = 1 + 1; # 声明的字面量可以是一个表达式
```

使用`let`声明的变量将被视为常量,常量一经创建,不可修改.  
常量采用大写+下划线的命名规范:  

```batscript
let CONST_1 = True; # 声明常量CONST_1,其值为True  
let CONST_2: arr<num>; # 声明常量但不赋值,其值将只为空值,并会给出警告  
```

一行语句可以声明多个类型相同且值相同的变量或常量:  

```batscript
let CONST_1 = CONST_2 = CONST_3 = 4; # CONST_1 == CONST_2 == CONST_3 == 4
```

### 空值和内建字面量  

#### 空值  

在`batScript`中,变量在声明时默认为`Nil`,直到被赋值.在赋值之后,也可以使用`[变量] = Nil`重新赋为空值.  
一种判断是否为空值的方式是使用`[变量] == Nil`判断.不过,更推荐使用判空运算符`?`:  

```batscript
set var_1: num; # Nil
?var_1; # True
var_1 = 1;
?var_1; # False
```

> 务必正确的在代码中处理空值,否则可能导致空值异常. 参阅[空值的标准处理]()  

#### 内建字面量  

表达式的"右端被称为字面量".需要注意的是,`batScript`不支持"无归属"的字面量.  

```batscript
"123"; # "无归属的字面量"
```

在`batScript`中,内建字面量指的是几个具有特殊含义的,由编译器内置的字面量,均采用首字母大写的方式.  
分别是:  

- `Nil`: 空值  
- `True`: 布尔真值  
- `False`: 布尔假值  

## 各类型的详细说明

在`batScript`中,类型分为两大类: 可迭代类型和不可迭代类型.  
其中,不可迭代类型即为不可逐个访问元素的类型,即单个值,包括`num`和`bool`.可迭代类型与相反,为可逐个访问元素的类型,包括`str`和`arr`.  

> 在`batScript`中,所有的变量都是值类型变量.`batScript`不存在引用的概念.  

### 不可迭代类型

#### `bool`: 布尔类型

最简单的类型就是布尔类型.非空的布尔变量要么是`True`,要么是`False`.  

```batscript
set bool_var = true;
bool_var = false;
```

#### `num`: 数字类型

数字类型是`batScript`内建的自定义类型,表示数字.其中,整数位可以无限大,小数位最多保留32位,有符号,足够大多数情况下的使用.  
数字间可以进行计算,计算结果会保留最少小数位和最少符号的形式(负数会包含负号`-`,正数默认没有符号).  

```batscript
set num_1: num = 1;
set num_2: num;

num_2 = num_1 + 1; # num_2 = 2
num_2 = num_2 - 0.5; # num_2 = 1.5;
num_2 = num_2 - 5 * num_1; # num_2 = -3.5
num_2 = +10000000000000000000000000000000000000000000000000000000000000000000; # num_2 = 10000000000000000000000000000000000000000000000000000000000000000000
num_2 = num_2 - 0.0000000000000000000000000000001; # num_2 = 9999999999999999999999999999999999999999999999999999999999999999999.9999999999999999999999999999999
num_2 = 00123; # num_2 = 123
```

> 当小数位超出32位时,将会直接截断  

> 在实际使用中,由于基于字符串运算且高精度的本质,不建议使用大于9位的数字  

数字可以进行格式化处理.最常用的是`Number`库提供的系列函数:  

```batscript
lib Number;

# 转换整数
set num_1: int = Num.toInt(3.1415926); # num_1: 3

# 小数位数保留: 截断, 向下, 向上, 四舍五入
num_1 = truncateDecimals(3.1415926,2); # num_1: 3.14
num_1 = floorDecimals(3.1415926,3); # num_1: 3.141
num_1 = ceilDecimals(3.1415926, 1); # num_1: 3.2
num_1 = roundDecimals(3.1415926, 2); # num_1: 3.14

# ...及其它更多方法
```

> 详见[Num库](../manual/库/Num库.md)  

### 可迭代类型

#### `str`: 字符串类型

字符串类型`str`用于表达一个字符串.  
可以使用`""`或`''`来表示一个标准字符串.  

> 目前这两者是等效的,不过计划在之后将`''`作为`b-string`语法.因此,从兼容性方面考虑,建议使用`""`  

```batscript
set str_1: str;
str_1 = "My String";
```

使用` `` `表示原始字符串.原始字符串内的内容不进行转义,在接下来的转义符部分进行更详细的讲解.  

##### 转义符

`""`和`''`支持一些C风格的基础转义符.详见[转义符表](../manual/语法/字符串转义符表.md):  

```batscript
lib Std;

/*
Hello
World
*/
Std.echo("Hello\nWorld");
```

> 尽管有些转义符目前尚不支持,但是在之后可能引入.因此,为了兼容性考虑,避免误使用C风格的全部转义符  

` `` `称为原始字符串.其内的内容将保留原有格式.例如,以下是和上述基本相同的代码,只是使用了` `` `:  

```batscript
lib Std;

/*
Hello\nWorld
*/
Std.echo(`Hello\nWorld`);
```

##### 输出

最常用的输出函数`Std.print()`接受的参数也是一个字符串:  

```batscript
lib Std;

set output_str: str = "HelloWorld!";
Std.print(output_str); # HelloWorld!
```

#### `arr`: 一维数组类型

一维数组是`batScript`支持的独特类型.  
一维数组在声明时,必须在结尾使用`<T>`定义类型.其中,`T`是以上三种类型的一种: 即一位数组内不能嵌套数组(否则也不是"一维"数组了).  
一维数组的每一项都是且只能是所定义的类型.通过`[]`表示一维数组,其中每一项之间通过`,`隔开,如`[1,2,3]`.支持尾逗号,如`[true,]`.  

```batscript
set num_arr: arr<num> = [0, 3.14, -100];
set str_arr: arr<str>; # []
```

> 之所以只实现为一位数组而不是列表等更高级的数据类型,主要考虑基于实现上难度和多数`.bat`本身较为简单固定的因素考虑  

未定义的`[]`字面量默认认为是`Nil`.  

```batscript
set arr_1: arr<num>;
arr_1 == [] == Nil; # True, 但是不建议这么写. 比如[Nil]是合法的, [[]]就会报错
```

##### 一维数组的高级构建

常用库`Array`的`build`系列方法提供了一位数组的一些高级构建.例如,以下函数用来构造均为某个值的一位数组:  

```batscript
lib Array;

set nuums_arr: arr<num> =  buildNumWithValue(1, 5); # [1, 1, 1, 1, 1]
set strs_arr: arr<num> = buildStrWithValue("", 2); # ["", ""]
set bools_arr: arr<num> = buildBoolWithValue(true, 0); # []
```

又比如,使用`buildNumByIncrease()`可以按照指定的递增值构建数组:  

```batscript
lib Array;

set arr_1: arr<num> = buildNumByIncrease(0, 1, 3); # 0作为第一项, 步进为1, 3个元素: [0, 1, 2]
```

高级构建的详细文档见[Array库](../manual/库/Arr库.md).  

#### 可迭代类型的通用语法

##### 索引

使用`[下标]`进行索引,获取指定位置的元素.下标是一个整数,起点是0:  

```batscript
set arr_1: arr<num> = [-1, 0, 1];
set arr_2: arr<str> = ["-1", "0", "1"];
set str_1: str = "String is iterateable.";

set var_1: num = arr_1[2]; # 1
set var_2: str = arr_2[0]; # "-1"
set var_3: str = str_1[1]; # "t"
```

###### 索引越界

在`batScript`中,访问越界的索引(即比当前的元素更多),将导致异常.如下列代码:  

```batscript
set arr_1: arr<num> = [1, 2, 3][3] # 索引越界.两个[][]的意思是,访问一维数组[1, 2, 3]的第3项
```

会导致异常信息如下:  

```powershell
batscript: Index out of range in array `arr_1` when trying to get value of index 3 (length: 3)
```

如果不希望导致该异常,一种方式是在索引前取长,添加逻辑进行预处理.例如,以下逻辑设定了异常自定义的异常:  

```batscript
set index: num = 4;
set string: str = "abc";

if (index - 1 >= &string)
{
    err "String" .. `"` .. string .. `"` .. "is shorter than" .. index + 1;
}

set content: str = string[index];
```

输出为:  

```powershell
batscript: String "abc" is shorter than 4
```

或者,使用`Iterateable`库中的`get`系列方法.如:  

```batscript
lib Iterateable;

Iterateable.getArrBool([true], 1); # 访问第二项.返回该类型的缺省值, 即bool的缺省值false
Iterateable.getArrBoolWithDefault([true], 1, true) # 访问第二项.返回设定的缺省值, 即第三个参数true
```

`get`的更多系列方法,见[Iterateable类](../manual/库/Iterateable库.md)中的详细说明.

##### 取长

使用`@`运算符可以获取对应可迭代类型的长度:  

```batscript
set empty_array: arr[str] = [];

set len_1 = @"string"; # 6
set len_2 = @empty_array; # 0
```

##### 拼接  

使用`..`运算符可以拼接相同的可迭代对象:  

```batscript
let my_str = "Hello " .. "World!"; # Hello World
set my_arr_1 = [True, False];
set my_arr_2 = [False, True];
my_arr_1 = my_arr_1 .. my_arr_2; # [True, False, False, True]
```

##### 追加  

使用`^`运算符可以在可迭代体的开头或结尾追加一个可迭代单元(即对于字符串,和拼接近似;对于数组,则是对应类型的单元).
当追加位于表达式左侧时,追加在开头;否则,追加到结尾.语法表示为`[可迭代体] ^ [可迭代单元]`(追加到结尾)或`[可迭代单元] ^ [可迭代体]`:

```batscript
let my_str = "1234" ^ "5"; # "12345"
let my_arr = 0 ^ [1, 2, 3, 4]; # [0, 1, 2, 3, 4]
```

需要注意的是,`^`优先执行追加到结尾.例如下列表达式:  

```batscript
let my_arr = 0 ^ [1] ^ 2; 
```

等价于  

```batscript
let my_arr = 0 ^ ([1] ^ 2); 
```

##### 变长  

使用`%%`运算符可以修改可迭代体的长度.  

当变长后的长度长于原先长度时:  

- 字符串: 追加`" "`  
- 数组: 追加`Nil`  

当变长后的长度小于原先长度时,则进行截断.  

语法表示为:`[可迭代体] %% [变长后的长度]`:  

```batscript
set str_1 = "1234" %% 5; # "1234 "
set arr_1 = [1, 2, 3] %% 1; # [1]
set arr_2 = [1];
arr_2 = arr_2 %% (@arr_2 + 1); # 变长一位: [1, Nil]
```

## 获取类型字符串和类型转换  

### 获取类型字符串  

使用`&`运算符,可以获取变量类型的字符串表示:  

```batscript
&3.14; # "num"
&"3.14"; # "str"
&[True]; # "arr<bool>"
&Nil == $[]; # True <- Nil == Nil 
```

### 类型转换  

在`batScript`中,类型可以使用`$`进行转换.语法是,`[转换后的类型]@[被转换的值]`:  

```batscript
set num_to_string: str = str$123; # "123"
set string_to_bool: bool = bool$"true"; # True
```

> 具体转换的逻辑,见[类型转换逻辑](../manual/语法/类型转换逻辑.md)  

---  

**导航**  

[上一个](#) | [下一个](#)  
[教程目录](#) | [手册导览](#) | [返回 README](#)
